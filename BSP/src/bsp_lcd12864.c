

/**********************************************************
* @ File name -> bsp_lcd12864.c
* @ Version   -> V1.1.2
* @ Date      -> 11-30-2013
* @ Brief     -> LCD12864驱动函数
*                适用于ST7920驱动芯片

 V1.1
* @ Revise    -> A、修正操作命令宏定义。
* @           -> B、增加串口、并口转换宏定义，增加对高速度MCU控制通讯频率延时函数
* @           -> C、显示字符串函数增加显示长度选择，即显示多少个ASCII可显示字符，汉字x2即可
* @           -> D、去掉显示数组函数，合并在字符串显示里

 V1.1.1
* @ Revise    -> 增加字符串显示函数，可以从要显示的数组中任意位置显示一定长度字符串

 V1.1.2
* @ Revise    -> A、增加对低速晶振系统的MCU通讯频率是否使用的宏定义
* @           -> B、增加在检测液晶忙超时退出，预防死循环
**********************************************************/
#include "bsp_lcd12864.h"
#include "includes.h"

/**********************************************************
                    自定义显示字符
**********************************************************/
#define CGRAM_Value                             64	//写入CGRAM数量
u8 CGROM_Code[] =
{
    //天线图形
    0xff, 0xff, 0x80, 0x01, 0xbf, 0xfd, 0xdf, 0xfb, 0xec, 0x37, 0xf6, 0x6f, 0xfb, 0xdf, 0xfd, 0xbf,
    0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xff, 0xff,

    //0x55,0x55,0x55,0x55,0xbf,0xfd,0xdf,0xfb,0xec,0x37,0xf6,0x6f,0xfb,0xdf,0xfd,0xbf,
    //0xfe,0x7f,0xfe,0x7f,0xfe,0x7f,0xfe,0x7f,0xfe,0x7f,0xfe,0x7f,0xfe,0x7f,0xff,0xff,
    //摄氏图形
    //						0x00,0x00,0x00,0x00,0x00,0x00,0x1c,0x70,0x14,0xd8,0x1d,0x88,0x01,0x80,0x01,0x80,
    //						0x01,0x80,0x01,0x80,0x01,0x88,0x00,0xc8,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
    //蓝牙图形
    0x07, 0xe0, 0x0e, 0x70, 0x1e, 0xb8, 0x3e, 0xdc, 0x36, 0xec, 0x3a, 0xdc, 0x3c, 0xbc, 0x3e, 0x7c,
    0x3e, 0x7c, 0x3c, 0xbc, 0x3a, 0xdc, 0x36, 0xec, 0x3e, 0xdc, 0x1e, 0xb8, 0x0e, 0x70, 0x07, 0xe0,

    //CD图形
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x07, 0xc9, 0xb3, 0x9d, 0xb9, 0x9f, 0xb9, 0x9f, 0xb9,
    0x9f, 0xb9, 0x9f, 0xb9, 0x9d, 0xb9, 0xc9, 0xb3, 0xe3, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    //右指向手型
    0x00, 0x00, 0x1e, 0x00, 0x12, 0x00, 0x73, 0xfc, 0x52, 0x02, 0x52, 0x1c, 0x53, 0xe0, 0x52, 0x10,
    0x53, 0xe0, 0x52, 0x10, 0x53, 0xe0, 0x52, 0x10, 0x73, 0xe0, 0x12, 0x00, 0x1e, 0x00, 0x00, 0x00
};
unsigned char CGROM_BAIHEJIU[] =

{ /*--  调入了一幅图像--*/
    /*--  宽度x高度=128x64  --*/
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x01, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x7F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x81, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x03, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x0F, 0xFF, 0xFE, 0x0F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1F, 0xFF, 0xC0, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x3F, 0xF0, 0x07, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x7F, 0x1F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x7E, 0xFF, 0xFF, 0xFF, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xF9, 0xFF, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0xF3, 0xFF, 0xFF, 0xF8, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0xF7, 0xFF, 0x80, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0xEF, 0xE0, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0xEF, 0x80, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0xDF, 0x00, 0x00, 0x3F, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0xDE, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0xDE, 0x00, 0x00, 0x03, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xDE, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xFE, 0x00, 0x00, 0x1E, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x6E, 0x00, 0x00, 0x7C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x7F, 0x00, 0x01, 0xF8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xB7, 0x80, 0x07, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xDB, 0xE0, 0x3F, 0xE3, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC9, 0xFF, 0xFF, 0xC3, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3F, 0xFC, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x01, 0xC0, 0x07, 0x80, 0x00, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x9F, 0xE0, 0x1F, 0x80, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xC0, 0x1F, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x03, 0xCF, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3F, 0x0F, 0x00, 0x07, 0xFF, 0x80, 0x39, 0xE0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3E, 0x7F, 0x80, 0x3F, 0x7F, 0x80, 0x7C, 0x70, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3E, 0x7D, 0x80, 0xFF, 0xF7, 0x01, 0xCC, 0x30, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x06, 0x7F, 0x80, 0xF7, 0xFF, 0x03, 0xED, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x7F, 0x80, 0x0F, 0x7F, 0x00, 0x7D, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x71, 0x80, 0x3F, 0xBE, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x7F, 0x80, 0x3F, 0x80, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x3F, 0x80, 0x3F, 0x00, 0x00, 0xF3, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x06, 0x03, 0x80, 0x03, 0x00, 0x03, 0xF1, 0xF0, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
unsigned char CGROM_YIFUYUAN[] =

{ /*--  调入了一幅图像:  --*/
    /*--  宽度x高度=128x64  --*/
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0xF8, 0xF0, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x83, 0xFF, 0x01, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1E, 0x0F, 0xFF, 0xC1, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x1F, 0xFF, 0xE1, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x60, 0x1F, 0xFF, 0xF0, 0x88, 0x07, 0x0F, 0xFF, 0xC1, 0xFD, 0xFF, 0xF0, 0xE3, 0xFF, 0xF8,
    0x01, 0xC0, 0x3F, 0xFF, 0xF8, 0x70, 0x07, 0x8F, 0xFF, 0xC1, 0xFD, 0xFF, 0xF0, 0xF3, 0xFF, 0xF8,
    0x03, 0x80, 0x3F, 0xFF, 0xFC, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x70, 0x71, 0xC0, 0xF3, 0x87, 0x00,
    0x07, 0x00, 0x3F, 0xFF, 0xCE, 0x00, 0x03, 0xC6, 0x07, 0x80, 0x00, 0x71, 0xC0, 0x73, 0x87, 0x00,
    0x0E, 0x00, 0x3F, 0xFF, 0x9F, 0x00, 0x01, 0xC7, 0x0F, 0x83, 0xFE, 0x7F, 0xC0, 0x73, 0xBF, 0xF8,
    0x1E, 0x00, 0x3F, 0xFF, 0x1F, 0x80, 0x00, 0x03, 0xDF, 0x03, 0xFE, 0x7F, 0xC0, 0x03, 0xBF, 0xF8,
    0x3C, 0x00, 0x3F, 0xFE, 0x0F, 0x80, 0x07, 0x81, 0xFE, 0x03, 0xFE, 0x7B, 0xC0, 0x03, 0xBF, 0xF8,
    0x7C, 0x00, 0x3F, 0xFE, 0x1F, 0xC0, 0x07, 0xC0, 0xFE, 0x00, 0x70, 0x71, 0xC0, 0xE3, 0xB8, 0x38,
    0x7C, 0x00, 0x3F, 0xFE, 0x1F, 0xC0, 0x07, 0xC1, 0xFF, 0x00, 0x70, 0x71, 0xC0, 0xF3, 0xB8, 0x38,
    0xF8, 0x00, 0x1F, 0xFE, 0x0F, 0xE0, 0x01, 0xCF, 0xFF, 0xE3, 0x76, 0x7F, 0xC0, 0x73, 0xBF, 0xF8,
    0xF8, 0x00, 0x1F, 0xFF, 0x1F, 0xE0, 0x01, 0xCF, 0x87, 0xE3, 0x76, 0x7F, 0xC0, 0x7B, 0xBF, 0xF8,
    0x70, 0x00, 0x0F, 0xFF, 0x8F, 0xE0, 0x01, 0xCC, 0x78, 0xE3, 0x76, 0xFF, 0xE0, 0x3B, 0xB8, 0x38,
    0x70, 0x00, 0x07, 0xFF, 0xCC, 0x30, 0x01, 0xC0, 0x78, 0x03, 0x77, 0xE0, 0xF0, 0x3B, 0xB8, 0x38,
    0x30, 0x00, 0x07, 0xFF, 0xF8, 0x30, 0x01, 0xC3, 0x7B, 0x03, 0x77, 0xDB, 0x78, 0x03, 0xB8, 0x38,
    0x10, 0x00, 0x01, 0xFF, 0xF1, 0xB0, 0x01, 0xCF, 0xFF, 0xC3, 0x77, 0x9B, 0x3C, 0x13, 0xBF, 0xF8,
    0x00, 0x00, 0x00, 0xFF, 0xF3, 0xB0, 0x01, 0xCF, 0xFF, 0xC3, 0x77, 0xFB, 0xFC, 0x3B, 0xBF, 0xF8,
    0x00, 0x00, 0x00, 0x3F, 0xF2, 0x78, 0x01, 0xC0, 0x78, 0x03, 0x77, 0xFB, 0xFC, 0x3B, 0x83, 0x80,
    0x40, 0x00, 0xF0, 0x1F, 0xFE, 0x78, 0x01, 0xC8, 0x78, 0x03, 0x74, 0x00, 0x00, 0x3B, 0xBB, 0xB8,
    0x40, 0x01, 0xF8, 0x0F, 0xFF, 0xF8, 0x01, 0xD8, 0x78, 0x03, 0x77, 0xFB, 0xFC, 0x7B, 0xBB, 0xB8,
    0xC0, 0x07, 0xFC, 0x07, 0xFF, 0xF8, 0x01, 0xF8, 0x78, 0x03, 0x77, 0xFB, 0xFC, 0x7B, 0xBB, 0xB8,
    0x80, 0x0F, 0xFC, 0x07, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0x83, 0x77, 0x9B, 0x3C, 0x7B, 0xBB, 0xB8,
    0x80, 0x0F, 0xFC, 0x03, 0xFF, 0xF0, 0x03, 0xEF, 0xFF, 0xC3, 0x77, 0x9B, 0x38, 0xFB, 0xBB, 0xB8,
    0x80, 0x0F, 0xBE, 0x03, 0xFF, 0xF0, 0x07, 0xC7, 0xFF, 0x83, 0x77, 0xDB, 0x78, 0xFB, 0x3B, 0xB8,
    0x80, 0x0F, 0xFE, 0x01, 0xFF, 0xF0, 0x07, 0x80, 0x78, 0x03, 0x76, 0xE0, 0xF0, 0xF3, 0x33, 0x98,
    0x80, 0x0F, 0xFE, 0x01, 0xFF, 0xF0, 0x03, 0x00, 0x78, 0x03, 0x76, 0x7F, 0xE0, 0xF2, 0x33, 0x98,
    0xC0, 0x07, 0xFE, 0x01, 0xFF, 0xE0, 0x00, 0x00, 0x78, 0x03, 0x76, 0x3F, 0xC0, 0xF2, 0x33, 0x98,
    0xC0, 0x03, 0xBC, 0x01, 0xFF, 0xE0, 0x00, 0x00, 0x30, 0x00, 0x70, 0x1F, 0x00, 0xE4, 0x21, 0x08,
    0xE0, 0x00, 0x78, 0x01, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x00, 0xF0, 0x01, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0x00, 0xE0, 0x01, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x01, 0xDF, 0x01, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x01, 0xBF, 0x81, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x03, 0xFF, 0x83, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x03, 0xFF, 0x83, 0xFE, 0x00, 0x00, 0x03, 0x37, 0x87, 0x99, 0x8C, 0xD9, 0x88, 0xC6, 0x00,
    0x3F, 0x03, 0xEF, 0x87, 0xFE, 0x00, 0x00, 0x03, 0x33, 0x06, 0x19, 0x8C, 0xD9, 0x9C, 0xE6, 0x00,
    0x1F, 0x83, 0xDF, 0x87, 0xFC, 0x00, 0x00, 0x01, 0xE3, 0x06, 0x19, 0x87, 0x99, 0xB6, 0xF6, 0x00,
    0x0F, 0xC3, 0xDF, 0x8F, 0xF8, 0x00, 0x00, 0x00, 0xC3, 0x07, 0x99, 0x83, 0x19, 0xBE, 0xDE, 0x00,
    0x07, 0xE3, 0xCF, 0x3F, 0xE0, 0x00, 0x00, 0x00, 0xC3, 0x06, 0x19, 0x83, 0x19, 0xB6, 0xCE, 0x00,
    0x03, 0xF1, 0xEE, 0x7F, 0xC0, 0x00, 0x00, 0x01, 0xE7, 0x86, 0x0F, 0x07, 0x8F, 0x36, 0xC6, 0x00,
    0x01, 0xF1, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xF1, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x3F, 0xF0, 0x90, 0x10, 0x12, 0x40, 0x40, 0x08, 0x3F, 0xF0, 0x90, 0x08, 0x07, 0xE2, 0x88,
    0x08, 0x24, 0x03, 0xFE, 0x3E, 0x12, 0x47, 0xFE, 0x08, 0x20, 0x13, 0xFE, 0x1F, 0x84, 0x22, 0xBF,
    0xFF, 0xA7, 0xE0, 0x90, 0x44, 0x12, 0x44, 0x02, 0xFF, 0xAF, 0xD0, 0x48, 0x21, 0x04, 0x22, 0xA9,
    0x88, 0xA9, 0x00, 0x00, 0x8A, 0x3F, 0xF3, 0xF8, 0x88, 0xA2, 0x11, 0xFC, 0xD2, 0x07, 0xE3, 0xFF,
    0x88, 0xAF, 0xF1, 0x88, 0x31, 0x12, 0x41, 0x44, 0x88, 0xAF, 0xD0, 0x50, 0x0C, 0x00, 0x02, 0x29,
    0x88, 0xA1, 0x00, 0x50, 0xC8, 0xD2, 0x42, 0xA8, 0x88, 0xA2, 0x97, 0xFF, 0x1F, 0xDE, 0x7B, 0xBF,
    0xFF, 0xA2, 0x80, 0x20, 0x2A, 0x13, 0xC7, 0x70, 0xFF, 0xA2, 0x51, 0x84, 0xF0, 0x52, 0x4A, 0x94,
    0x08, 0x24, 0x40, 0x50, 0x49, 0x12, 0x40, 0xA8, 0x08, 0x2F, 0xD6, 0xFC, 0x10, 0x52, 0x4A, 0xFF,
    0x08, 0x28, 0x20, 0x88, 0x14, 0x10, 0x07, 0x26, 0x08, 0x20, 0x10, 0x84, 0x10, 0x52, 0x4A, 0x84,
    0x08, 0x3F, 0xF7, 0x06, 0xE3, 0xDF, 0xF0, 0xC0, 0x08, 0x3F, 0xF0, 0xFC, 0x1F, 0xDE, 0x7A, 0x84,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//=========================================================
//=========================================================

/**********************************************************
* 函数功能 ---> LCD启动字节
* 入口参数 ---> dt：传输的字节，高5位在函数内部设定为1
*               只是确定RW和RS为，最后那位也是内部确定
* 返回数值 ---> none
* 功能说明 ---> 首先传送一个启动字节，送入连续5个“1”用来启
*               动一个周期，此时传输计数被重置，并且串行传输
*               被同步，紧接着的两个位指定传输方向（R/W，确
*               定是读还是写）和传输性质（RS，确定是命令寄存
*               器还是数据寄存器），最后的第八位是一个“0”
**********************************************************/
void LCD12864_Start( u8 dt )
{
    u8 dat, j;

    dat = dt | 0xf8;                                                            //高5位设定为“1”，第八位设定为“0”
    LCD_SCL_RESET;
    lcdDelay();
    LCD_CS_SET;                                                                 //选中显示屏，高电平有效

    for ( j = 0; j < 8; j++ )
    {
        if ( dat & 0x80 )
            LCD_SDA_SET; //放数据到数据线
        else
            LCD_SDA_RESET;

        lcdDelay();
        LCD_SCL_SET;                                                            //发送数据，上升沿有效
        lcdDelay();
        LCD_SCL_RESET;
        dat <<= 1;                                                              //左移一位，先发的是高位
    }

    lcdDelay();
    LCD_SCL_RESET;
    lcdDelay();                                                                //等待硬件反应（等待数据发送完全）
}

/**********************************************************
* 函数功能 ---> LCD写入一个字节命令或者数据
* 入口参数 ---> dat：要写入的命令或者数据
*               ord：命令或者数据判断为。0为命令，1为数据
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
#if 0
void lcdWriteByte( u8 dat, u8 ord )
{
    u8 tem;
    u8 i, j;

    tem = dat & 0xf0;                                                           //先发送高4位
    LCD12864_Start( ( ord << 1 ) | 0xf0 );                                      //置RW为“0”、RS为“ord”并启动串行传输为数据格式

    for ( j = 0; j < 2; j++ ) //一个字节数据或者命令分两次发送
    {
        LCD_SCL_RESET;                                                          //允许数据线电平变化
        lcdDelay();

        for ( i = 0; i < 8; i++ )
        {
            if ( tem & 0x80 )
                LCD_SDA_SET; //放上数据，屏蔽低4位
            else
                LCD_SDA_RESET;

            lcdDelay();
            LCD_SCL_SET;                                                        //发送数据，上升沿有效
            lcdDelay();
            LCD_SCL_RESET;
            tem <<= 1;                                                          //左移一位，先发的是高位
        }

        tem = ( dat << 4 ) & 0xf0;                                              //发完高4位，再次发送低4位
    }

    lcdDelay();
    LCD_SDA_RESET;
    lcdDelay();
    LCD_SCL_RESET;
    lcdDelay();
    LCD_CS_RESET;
    lcdDelay();                                                                //等待硬件反应（等待数据发送完全）
}
#endif

void lcdWriteByte( u8 dat, u8 ord )
{

    FONT_SPI_FLASH_SendByte( ( ord << 1 ) | 0xf8);  //LCD12864_Start( ( ord << 1 ) | 0xf0 ); //置RW为“0”、RS为“ord”并启动串行传输为数据格式

    FONT_SPI_FLASH_SendByte( dat & 0xf0 );          //先发送高4位

    FONT_SPI_FLASH_SendByte(( dat << 4 ) & 0xf0);   //再发低高4位

}


//=========================================================

/**********************************************************
* 函数功能 ---> 设置LCD显示位置
* 入口参数 ---> x：行，取值范围：1 ~ 4
*               y：列，取值范围：0 ~ 7
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void lcdSetXy( u8 x, u8 y )
{
    switch ( y )
    {
        case 0:
        case 1:
            lcdWriteByte( ( One_LineAddress + x ), 0 ); //写入操作地址
            break;

        case 2:
        case 3:
            lcdWriteByte( ( Two_LineAddress + x ), 0 ); //写入操作地址
            break;

        case 4:
        case 5:
            lcdWriteByte( ( Three_LineAddress + x ), 0 ); //写入操作地址
            break;

        case 6:
        case 7:
            lcdWriteByte( ( Four_LineAddress + x ), 0 ); //写入操作地址
            break;

        default:
            lcdWriteByte( ( One_LineAddress + x ), 0 ); //写入操作地址
            break;
    }
}

/**********************************************************
* 函数功能 ---> 写入自定义字符到LCD的CGRAM
* 入口参数 ---> *data_code：写入的数组
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void lcdWriteCGRAM( u8 * data_code )
{
    unsigned char x, y, i;
    unsigned int tmp = 0;

    for ( i = 0; i < 9; )
    { //分两屏，上半屏和下半屏，因为起始地址不同，需要分开

        for ( x = 0; x < 32; x++ )
        { // 32行
            lcdWriteByte( 0x34, 0 );
            lcdWriteByte( ( 0x80 + x ), 0 );                                  // 列地址
            lcdWriteByte( ( 0x80 + i ), 0 );                                  // 行地址，下半屏，即第三行地址0X88
            lcdWriteByte( 0x30, 0 );

            for ( y = 0; y < 16; y++ )
                lcdWriteByte( data_code[tmp + y], 1 ); // 读取数据写入LCD

            tmp += 16;
        }

        i   += 8;
    }

    lcdWriteByte( 0x36, 0 );                                                  //扩充功能设定
    lcdWriteByte( 0x30, 0 );
}

/**********************************************************
* 函数功能 ---> 显示一个CGRAM内容
* 入口参数 ---> x：行
*               y：列
*               *str为要显示的字符串
*               add_h：CGRAM高位地址
*               add_l：CGRAM低位地址
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void displayCGRAM( u8 x, u8 y, u8 add_h, u8 add_l )
{
    lcdSetXy( x, y );                                                         //设置显示地址
    lcdWriteByte( add_h, 1 );
    lcdWriteByte( add_l, 1 );
}

/**********************************************************
* 函数功能 ---> LCD显示字符串
* 入口参数 ---> x：行
*               y：列
*               *str：要显示的字符串
*               len：显示的长度
* 返回数值 ---> none
* 功能说明 ---> 可以从显示数组的任意位置starsum开始显示len长度的字符串
**********************************************************/
void displayGB2312String( u8 x, u8 y, u8 * text, u8 isTurn )
{
    u8 i = 0;

    lcdSetXy( x, y );                                                         //设置显示地址

    if ( text )
    {
        while ( ( text[i] > 0x00 ) && i < 16 )
        {
            text[i] > 0x20 ? lcdWriteByte( text[i], 1 ): lcdWriteByte( 0x20, 1 );
            i++;
        }
    }
    /*
    if(isTurn)
    {
        lcdWriteByte( 0x30, 0 );
        lcdSetXy( 0, y );
        lcdWriteByte( 0x0d, 0 );
    }
    else
    {
        lcdWriteByte( 0x30, 0 );
        lcdSetXy( 0, y );
        lcdWriteByte( 0x0c, 0 );
    }
    */

}

/**********************************************************
* 函数功能 ---> LCD显示字符串
* 入口参数 ---> x：行
*               y：列
*               *str：要显示的字符串
*               len：显示的长度
* 返回数值 ---> none
* 功能说明 ---> 可以从显示数组的任意位置starsum开始显示len长度的字符串
**********************************************************/
void displayGB2312StringLen( u8 x, u8 y, u8 * text, u8 isTurn, u8 len )
{
    u8 i = 0;

    lcdSetXy( x, y );                                                         //设置显示地址

    if ( text )
    {
        while ( ( text[i] > 0x00 ) && i < len )
        {
            text[i] > 0x20 ? lcdWriteByte( text[i], 1 ): lcdWriteByte( 0x20, 1 );
            i++;
        }
    }
}

/**********************************************************
* 函数功能 ---> LCD显示字符串
* 入口参数 ---> x：行
*               y：列
*               *str：要显示的字符串
*               len：显示的长度
* 返回数值 ---> none
* 功能说明 ---> 只能从数组的开头开始显示len长度字符串
**********************************************************/
void displayString( u8 x, u8 y, u8 * str, u8 len )
{
    lcdSetXy( x, y );                                                         //设置显示地址

    while ( len-- )
    {
        lcdWriteByte( *str, 1 );
        str++;
    }
}

/**********************************************************
* 函数功能 ---> LCD显示字符串
* 入口参数 ---> x：行
*               y：列
*               *str：要显示的字符串
*               len：显示的长度
* 返回数值 ---> none
* 功能说明 ---> 可以从显示数组的任意位置starsum开始显示len长度的字符串
**********************************************************/
void displayStringFromIndex( u8 x, u8 y, u8 * str, u8 starsum, u8 len )
{
    u8 i;

    lcdSetXy( x, y );                                                         //设置显示地址

    for ( i = starsum; i < starsum + len; i++ )
    {
        lcdWriteByte( str[i], 1 );
    }
}

/**********************************************************
* 函数功能 ---> LCD写入GDRAM绘图
* 入口参数 ---> x：行
*               y：列
*               width：显示图片的宽度
*               hieght：显示图片的高度
*               *bmp：要显示的字符串
*               dis_mode：显示模式，是半屏显示还是全屏显示
*                         0：半屏显示。1：全屏显示
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void displayGDRAM( u8 x, u8 y, u8 width, u8 height, u8 * bmp, u8 dis_mode )
{
    u8 i, j, k;
    u8 base_x, base_y;                                                          //起始坐标

    /******全屏绘图显示******/
    if ( dis_mode )
    {
        switch ( x )
        {
            case 1:
                base_y = One_LineAddress + y;
                break;

            case 2:
                base_y = Two_LineAddress + y;
                break;

            case 3:
                base_y = Three_LineAddress + y;
                break;

            case 4:
                base_y = Four_LineAddress + y;
                break;

            default:
                break;
        }

        lcdWriteByte( MPU_8bit_Expansion_Draw_Close, 0 );                     //扩充指令
        lcdWriteByte( MPU_8bit_Expansion_Draw_Open, 0 );                      //打开绘图功能

        for ( j = 0; j < height; j++ ) //32
        {
            lcdWriteByte( base_y + j, 0 );                                    //写入行号，即第几行开始
            lcdWriteByte( One_LineAddress, 0 );                               //横坐标的第几个字节开始写

            for ( i = 0; i < width; i++ ) //上半屏
            {
                lcdWriteByte( bmp[width * j + i], 1 );                        //开始写入数据
            }

            for ( k = 0; k < width; k++ ) //下半屏
            {
                lcdWriteByte( bmp[width * ( j + height ) +k], 1 );            //开始写入数据
            }
        }
    }

    /******分开上半屏或者下半屏写******/
    else
    {
        switch ( x ) //判断显示的横坐标，确定起始行
        {
            case 1: //上半屏
                base_x = One_LineAddress; //起始地址为0x80
                break;

            case 2: //下半屏
                base_x = One_LineAddress; //起始地址为0x80
                break;

            case 3: //下半屏
                base_x = Three_LineAddress; //起始地址为0x88
                break;

            default:
                break;
        }

        base_y = base_x + y;                                                    //x轴方向的偏移，基地址 + 偏移地址
        lcdWriteByte( MPU_8bit_Expansion_Draw_Close, 0 );                     //扩充指令
        lcdWriteByte( MPU_8bit_Expansion_Draw_Open, 0 );                      //打开绘图功能

        if ( x == 1 || x == 3 ) //直接在同一个半屏的，直接写完32位数据
        {
            for ( i = 0; i < 32; i++ ) //写地址有讲究，先写垂直再写水平，详见“设定绘图RAM地址”说明
            {
                lcdWriteByte( One_LineAddress + i, 0 );                       //写入垂直地址，不管上半屏还是下半屏
                lcdWriteByte( base_y, 0 );                                    //写入水平地址

                for ( j = 0; j < 2; j++ ) //两组8bit数据，组成16bit
                {
                    lcdWriteByte( *bmp++, 1 );                                //写入数据
                }
            }
        }

        if ( x == 2 ) //数据显示不在同一半屏上的，先写上半屏，在写下半屏
        {
            for ( i = 0; i < 16; i++ ) //上半屏16行点阵数据
            {
                lcdWriteByte( Two_LineAddress + i, 0 );                       //写入垂直地址
                lcdWriteByte( base_y, 0 );                                    //写入水平地址

                for ( j = 0; j < 2; j++ ) //两组8bit数据，组成16bit
                {
                    lcdWriteByte( *bmp++, 1 );                                //写入数据
                }
            }

            for ( i = 0; i < 16; i++ ) //下半屏16行点阵数据
            {
                lcdWriteByte( Three_LineAddress + i, 0 );                     //写入垂直地址
                lcdWriteByte( base_y + 8, 0 );                                //写入水平地址

                for ( j = 0; j < 2; j++ ) //两组8bit数据，组成16bit
                {
                    lcdWriteByte( *bmp++, 1 );                                //写入数据
                }
            }
        }
    }

    lcdWriteByte( MPU_8bit_Expansion_Draw_Open, 0 );                          //扩充指令，打开绘图功能

    //	lcdWriteByte(Instruct_Basic8,0);
}

/**********************************************************
* 函数功能 ---> LCD12864清屏
* 入口参数 ---> none
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void lcd12864Clear( void )
{
    lcdWriteByte( Clear_Display, 0 );                                         //清屏
    delayUs( 10000 );                                      // 延时等待清屏完成
}

/**********************************************************
* 函数功能 ---> LCD12864初始化
* 入口参数 ---> none
* 返回数值 ---> none
* 功能说明 ---> none
**********************************************************/
void lcd12864Init( void )
{
    /*********************************/
    LCD_RST_RESET;                                                              //显示屏复位
    delayMs( 6 );
    LCD_RST_SET;
    delayMs( 6 );
    lcdWriteByte( Instruct_Basic8, 0 );                                       //基本指令，8bit模式,0x30
    lcdWriteByte( Instruct_Basic8, 0 );                                       //基本指令，8bit模式,0x30
    lcdWriteByte( Open_Display, 0 );                                          //整体显示开，光标关，显示反白关,0x0c
    lcdWriteByte( Clear_Display, 0 );                                         //清屏,0x01
    lcdWriteByte( Vernier_ShiftRight, 0 );                                    //设定起点，光标右移,0x06
    delayMs( 6 );
    LCD_BAK_RESET;

    /*******************************/
    //lcdWriteCGRAM(CGROM_BAIHEJIU);              //写入自定义字符
    //lcdWriteCGRAM(CGROM_YIFUYUAN);              //写入自定义字符
}

/*********************************************************/
void delay_us( int delay )
{
    int i = delay;

    while ( i-- )
        ;
}

// 反显
void isTurnShow( u8 x, u8 y )
{
    if ( y < 5 )
    {
        lcdWriteByte( 0x30, 0 );
        lcdSetXy( 0, y * 2 );
        lcdWriteByte( 0x0d, 0 );
    }
    else
    {
        lcdWriteByte( 0x30, 0 );
        lcdSetXy( 0, y * 2 );
        lcdWriteByte( 0x0c, 0 );
    }
}

/*****
反白思想:
从使用手册上可知，扩展指令里的0x03+行号即可实现反白对应行。但是ST7920 控制器的128×64 点阵液晶其实原理上等同256×32 点阵，第三行对应的DDRAM 地址紧接第一行；第四行对应的DDRAM 地址紧接第二行。所以128×64
点阵的液晶执行反白功能时实用意义不大，因为用户对第一行执行反白显示操作时，第三行必然也反白显示；第二行反白，第四行也必然反白。

        其实我们还是有办法做到单行反白的，解决方法就是混用图形显示和字符显示。其理论支持在于：在ST7920中，字符显示的CGRAM和图形的GGRAM是相互独立的，而最后显示到液晶上的结果，是两个RAM中数据的异或。
具体来说：假如某个点上，绘图RAM的没有绘图（数据为0），而字符RAM上有点阵（数据为1），那么异或的结果就是1，也就是说正常显示字符；当字符上RAM没有点阵的时候，异或的结果是0，自然也就不显示了。假如该点上绘图RAM图了（数据为1），当字符RAM上有点阵（数据为1时），异或的结果为0，效果就是反白显示；如果字符RAM没有点阵（数据为0时），异或结果为1，效果就是显示绘图的背景。

        所以，如果要在某个地方反白显示，那么就在该点绘图并且写字，如果要取消反白，就重新用全0擦掉那个地方的绘图！这样一来可以实现任何地方、任意大小的反白显示，反而比原指令中的单行反白的功能更好更强大咯
12864驱动程序（反白部份）

*****/
void dispBlack() //在反白之前先清绘图存储区,将绘图存储区的参数全设为不反白0x00.
{
    unsigned char i, j;

    lcdWriteByte( 0x36, 0 );                                                      //图形方式

    for ( i = 0; i < 32; i++ )
    {
        lcdWriteByte( 0x80 + i,0 );
        lcdWriteByte( 0x80, 0 );

        for ( j = 0; j < 16; j++ )
        {
            lcdWriteByte( 0x00, 1);
        }
    }

    for ( i = 0; i < 32; i++ )
    {
        lcdWriteByte( 0x80 + i,0 );
        lcdWriteByte( 0x80, 0 );

        for ( j = 0; j < 16; j++ )
        {
            lcdWriteByte( 0x00, 1 );
        }
    }
}
void convertChar( u8 x, u8 y, u8 width, u8 yn, u8 f )
{

    u8 halfLineCnt = 0;
    u8 basicBlock = 0;
    u8 lcdPosX = 0;
    u8 lcdPosY = 0;

    if ( f == 1 )
        dispBlack(); //清绘图区

    lcdPosY = 0x80;

    if ( x == 0 )
    {
        x  = 0x80;
        halfLineCnt = 16;
    }
    else if ( x == 1 )
    {
        x  = 0x80;
        halfLineCnt = 32;
    }
    else if ( x == 2 )
    {
        x  = 0x88;
        halfLineCnt = 16;
    }
    else if ( x == 3 )
    {
        x  = 0x88;
        halfLineCnt = 32;
    }

    lcdPosX = x + y;

    for ( ; halfLineCnt != 0; halfLineCnt-- )
    {
        basicBlock = width;
        lcdWriteByte( 0x34, 0 );
        lcdWriteByte( lcdPosY, 0 );
        lcdWriteByte( lcdPosX, 0 );
        lcdWriteByte( 0x30, 0 );

        for ( ; basicBlock != 0; basicBlock-- )
        {
            if ( halfLineCnt > 16 )
            {
                lcdWriteByte( 0x00, 1 );
            }
            else
            {
                if ( yn == 1 )
                    lcdWriteByte( 0xff, 1 );
                else
                    lcdWriteByte( 0x00, 1 );
            }
        }

        lcdPosY++;
    }

    lcdWriteByte( 0x36, 0 );
    lcdWriteByte( 0x30, 0 );
}



/*******************************************************************************
* Function Name  : GPIO_Configuration
* Description    : Configure GPIO Pin
* Input          : None
* Output         : None
* Return         : None
* Attention		 : None
*******************************************************************************/
void gpioConfiguration( void )
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE );

    /**
    *   LCD
    */
    GPIO_InitStructure.GPIO_Pin = LCD_RST | LCD_BAK;  //    LCD_SCL | LCD_SDA | LCD_CS |
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init( GPIOB, &GPIO_InitStructure );
}


void lcdInit( void )
{
    gpioConfiguration();                                                        // 初始化GPIO
    FONT_SPI_FLASH_Init();      // 作为LCD的显示引脚
    lcd12864Init();
}
